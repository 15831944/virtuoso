<?xml version="1.0" encoding="ISO-8859-1"?>
<refentry id="fn_ttlp_mt">
  <refmeta>
    <refentrytitle>DB.DBA.TTLP_MT</refentrytitle>
    <refmiscinfo>rdf</refmiscinfo>
  </refmeta>
  <refnamediv>
    <refname>DB.DBA.TTLP_MT</refname>
    <refpurpose>parses TTL (TURTLE or N3 resource) and places its triples into DB.DBA.RDF_QUAD on multiple threads.</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <funcsynopsis id="fsyn_ttlp_mt">
      <funcprototype id="fproto_ttlp_mt">
        <funcdef><function>DB.DBA.TTLP_MT</function></funcdef>
	<paramdef>in <parameter>strg</parameter> any</paramdef>
	<paramdef>in <parameter>base</parameter> varchar</paramdef>
	<paramdef><optional>in <parameter>graph</parameter> varchar</optional></paramdef>
        <paramdef><optional>in <parameter>flags</parameter> integer</optional></paramdef>
        <paramdef><optional>in <parameter>log_mode</parameter> integer</optional></paramdef>
        <paramdef><optional>in <parameter>threads</parameter> integer</optional></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>
  <refsect1 id="desc_ttlp_mt">
    <title>Description</title>
    <para>Loads the TTL (TURTLE or N3 resource) file on multiple threads, using parallel I/O and multiprocessing if available. The function commit partial transactions while it runs so the transaction log may contain part of loading. Moreover, the function may or may not leave a transaction log, depending on <parameter>log_mode</parameter>. Hence, after successful load, one may need to execute the checkpoint statement to make sure that a server restart does not wipe out the results.</para>
  </refsect1>
  <refsect1 id="params_ttlp_mt">
    <title>Parameters</title>
    <refsect2><title>strg</title>
      <para>text of the resource</para>
    </refsect2>
    <refsect2><title>base</title>
      <para>base IRI to resolve relative IRIs to absolute</para>
    </refsect2>
    <refsect2><title>graph</title>
      <para>target graph IRI, parsed triples will appear in that graph.</para>
    </refsect2>
    <refsect2><title>flags</title>
      <para>bitmask of flags that permit some sorts of syntax errors in resource, use 0.</para>
    </refsect2>
    <refsect2><title>log_mode</title>
      <para>detail level of writing the effect of loading to the transaction log. 0 means log nothing, 1 means log only allocations of internal IDs for new IRIs and literals, 2 means log everything. If database crashes when the loading is in progress or after the loading but before checkpoint is made, 0 will means that the database become inconsistent, 1 means that the database is consistent but loaded quads may disappear so the loading should be repeated and log replay may produce wrong results if actions in it depend on the content of quad store, 2 means no danger (so the default is 2). Hence loading with mode 1 and especially mode 0 are faster than usual mode 2 but they require checkpoints after data loadings and mode 0 additionally requires a checkpoint and database backup right before the loading.</para>
    </refsect2>
    <refsect2><title>threads</title>
      <para>number of threads that insert quads into the database. It should not be less than 1, obviously; it is better to not set it greater than <emphasis>((N-2)/k)-1</emphasis> where <emphasis>N</emphasis> is the number of available CPU cores and <emphasis>k</emphasis> is the number of loadings that happen at the same time.</para>
    </refsect2>
  </refsect1>
  <refsect1 id="ret_ttlp_mt"><title>Return Types</title>
    <para>The return value is not specified and may be changed in future versions.</para>
  </refsect1>
<!--  <refsect1 id="errors_ttlp_mt">
    <title>Errors</title>
    <para>This function can generate the following errors:</para>
    <errorcode></errorcode>
  </refsect1>
-->
  <refsect1 id="examples_ttlp_mt">
    <title>Examples</title>
    <example id="ex_ttlp_mt"><title></title>
<para></para>
<screen><![CDATA[
create procedure SPARQL_DAWG_LOAD_REMOTE_DATFILE (in full_uri varchar, in in_resultset integer := 0)
{
  declare REPORT varchar;
  declare graph_uri, dattext varchar;
  declare app_env any;
  app_env := null;
  whenever sqlstate '*' goto err_rep;
  if (not in_resultset)
    result_names (REPORT);
  dattext := cast (XML_URI_GET_AND_CACHE (full_uri) as varchar);
  SPARQL_REPORT (sprintf ('Downloading %s: %d bytes',
      full_uri, length (dattext) ) );
  graph_uri := full_uri;
  delete from RDF_QUAD where G = DB.DBA.RDF_MAKE_IID_OF_QNAME (graph_uri);
  if ((full_uri like '%.ttl') or (full_uri like '%.nt') or (full_uri like '%.n3'))
    DB.DBA.TTLP_MT (dattext, full_uri, graph_uri);
  else -- if (rel_path like '%.rdf')
    DB.DBA.RDF_LOAD_RDFXML_MT (dattext, full_uri, graph_uri);
  return graph_uri;
err_rep:
  result (sprintf ('%s: %s', __SQL_STATE, __SQL_MESSAGE));
  return graph_uri;
}
;
]]></screen>
    </example>
  </refsect1>
  <refsect1 id="seealso_ttlp_mt">
    <title>See Also</title>
    <para><link linkend="fn_rdf_audit_metadata"><function>DB.DBA.RDF_AUDIT_METADATA</function></link></para>
    <para><link linkend="fn_rdf_backup_metadata"><function>DB.DBA.RDF_BACKUP_METADATA</function></link></para>
    <para><link linkend="fn_rdf_load_rdfxml"><function>DB.DBA.RDF_LOAD_RDFXML</function></link></para>
    <para><link linkend="fn_rdf_load_rdfxml_mt"><function>DB.DBA.RDF_LOAD_RDFXML_MT</function></link></para>
    <para><link linkend="fn_ttlp"><function>DB.DBA.TTLP</function></link></para>
  </refsect1>
</refentry>
